# 第二章：深入JavaScript

在上一章中，我介绍了编程的基本要素，如变量、循环、条件语句和函数等。当然，所有的代码也都是用JavaScript表示的。本章中，我们将主要关注一个JS开发者从入门到进阶需要了解的JavaScript的方方面面。

本章我我将介绍一些在以后的 *YDKJS* 书籍中才会详细讲解的概念。你可以把本章作为一个后续书籍深入讨论的主题的一个总览。

如果你是JavaScript的初学者，你应该多花些时间反复复习本章的概念和代码示例。任何伟大的建筑都是由一砖一瓦堆砌而成的，所以不要期望能够第一遍就能完全掌握所有的知识点。

现在让我们开始深入学习JavaScript之旅吧！

## 值&类型
我们在第一章中提到过，JavaScript的值是有类型的，而变量是没有类型的。JavaScript有下列的内置类型：
* `string`
* `number`
* `boolean`
* `null` 和 `undefined`
* `object`
* `symbol` (ES6中新引入)
JavaScript中可以用`typeof`操作符来查看某个值属于什么类型：
```js
var a;
typeof a;				// "undefined"

a = "hello world";
typeof a;				// "string"

a = 42;
typeof a;				// "number"

a = true;
typeof a;				// "boolean"

a = null;
typeof a;				// "object" -- weird, bug

a = undefined;
typeof a;				// "undefined"

a = { b: "c" };
typeof a;				// "object"
```
`typeof`操作符的返回值永远是六种类型之一（ES6中是7种类型，包括'symbol'类型）的字符串值。例如，`typeof "abc"`返回`"string"`，而不是`string`。

注意上面的代码中变量a可以保存不同类型的值，`typeof a`不是获取变量a的类型，而是获取变量a中当前值的类型。JavaScript中只有值才有类型，而变量仅仅是存放这些值的容器。

`typeof null`是一个有意思的例子，因为它会错误地返回"object"，而不是预料中的"null"。
**注意：** 这是JS的一个遗留bug，但是可能永远也不会修复。由于Web中有太多的代码依赖于这个bug，因此修正这个bug可能会导致更多的bug！

还要注意`a = undefined`。这里显示地给变量a赋值为undefined值，这在表现上与没有给变量a设置任何值的情况是一样的，如上面代码第一行的var a。有几种情况会使得变量的值为"undefined"，包括没有返回值和使用了void操作符的函数。

### 对象
`object`类型表示一类可以设置属性（命名的位置符）的复合值，每个属性保存它们自己的任意类型的值。对象可能是JavaScirpt中最有用的值类型了。
```js
var obj = {
	a: "hello world",
	b: 42,
	c: true
};

obj.a;		// "hello world"
obj.b;		// 42
obj.c;		// true

obj["a"];	// "hello world"
obj["b"];	// 42
obj["c"];	// true
```
将这个obj对象可视化为如下形式有助于理解：

|a             |b   |c     |
|:------------:|:--:|:----:|
|"hello world" | 42 | true |
可以用 *点记法*（即`obj.a`）或 *括号记法*（即`obj['a']`）来访问对象的属性。点记法更简单且易读，因此尽可能的使用点记法。
如果属性名中包含特殊字符，则应该使用括号记法，如`obj["hello world!"]`——通过括号记法访问的属性通常作为 *键值*。`[ ]`中要么是一个变量（稍后解释），要么是一个 *字面量字符串*（包裹在`".."`或`'..'`中）。
当然如果你想访问的键值对的名字保存在另一个变量中，也应该使用括号记法，如：
```js
var obj = {
	a: "hello world",
	b: 42
};

var b = "a";

obj[b];			// "hello world"
obj["b"];		// 42
```
**注：** 查看更多有关JavaScirpt对象的知识点，参考 *this&对象原型* 一书，特别是第三章。

JavaScirpt中还有两种常见的值类型：*数组* 和 *函数*。它们不是内置的值类型，而更像是子类型——特殊的`object`类型。

#### 数组
数组是按数字索引顺序保存属性值的对象，如：
```js
var arr = [
	"hello world",
	42,
	true
];

arr[0];			// "hello world"
arr[1];			// 42
arr[2];			// true
arr.length;		// 3

typeof arr;		// "object"
```
**注：** 编程语言从0开始计数，JS也不例外，将`0`作为数组第一个元素的索引。
`arr`的可视化形式如下：

|0             |1   |2     |
|:------------:|:--:|:----:|
|"hello world" | 42 | true |
由于数组是特殊的对象（如`typeof`的结果所示），因此也可以有属性，包括自动更新的`length`属性。

理论上通过自定义属性名，可以把数组当作正常的对象使用，也可以用`object`来模拟数组，只需将其属性用数字（0，1，2等）即可。当然这样的用法不利于区别不同的值类型。

最好且最自然的方式是用数组表示以数字做索引的值，而用`object`表示具有命名属性的值。

#### 函数
JS程序中常见的另一个`object`子类型是函数：
```js
function foo() {
	return 42;
}

foo.bar = "hello world";

typeof foo;			// "function"
typeof foo();		// "number"
typeof foo.bar;		// "string"
```
再次强调，函数是`object`的子类型——`typeof`返回`"function"`，表明function是一个主要类型——因此可以有属性，但是一般只有在少数情况下才会用函数的对象属性（如`foo.bar`）。

**注：** 更多关于JS值及其类型的知识，参考 *类型&语法* 一书的第二章。

### 内置类型的方法
我们前面讨论的内置类型和子类型暴露了很多强大而实用的属性和方法。如：
```js
var a = "hello world";
var b = 3.14159;

a.length;               // 11
a.toUpperCase();        // "HELLO WORLD"
b.toFixed(4);           // "3.1416"
```
这里`a.toUpperCase()`函数背后的调用机制比表面上看起来复杂的多。简单来说，与原始`string`类型对应地有一个“原生”`String`（大写字母S）的对象封装形式；正是在这个对象封装器的原型上定义了`toUpperCase()`方法。

当引用原始字符串值如"hello world"的属性或方法时（如a.toUpperCase()），JS自动将这个值“放入”对应的对象封装器中（表面上看不出区别）。

string值可以被String对象封装，number值可以被Number对象封装，而boolean值可以被Boolean对戏那个封装。在大多数情况下，我们直接使用值的对象封装形式就行——几乎任何时候原始值形式都用得更多，JavaScript会处理剩下的事情。

**注：** 更多关于JS原生和“封装”的知识，参考 *类型&语法* 一书的第三章。想深入理解对象原型的概念，参考 *this&对象原型* 一书的第五章。

### 比较值
在JS程序中主要需要做两种类型的值比较：*等式* 和 *不等式*。不管进行何种值的比较，结果都是一个boolean值（true或false）。

#### 强制转换
我们在第一章中简要讨论了强制转换，现在我们温习一下。

JavaScript中有两种形式的强制转换：*显示* 和 *隐式*。从一种类型值转换为另一种类型值的代码中就会发生显示强制转换，而隐式转换在一些操作符不带来副作用的情况上才会发生。

你可能听说过“强制转换是恶魔”的论调，因为很多情况下强制转换会带来意想不到的结果。也许没有什么能比JS语言带给开发者更多挫败感了。

强制转换不是恶魔，也不一定不可控。实际上，在大多数情况下使用强制类型转换都是合理且可理解的，甚至可以有效地提高代码的可读性。这里我们不做详细讨论——*类型&语法* 一书的第四章会详细阐述。

下面是一个显示转换的例子：
```js
var a = "42";

var b = Number( a );

a;              // "42"
b;              // 42 -- the number!
```
这是一个隐式转换的例子：
```js
var a = "42";

var b = a * 1;  // "42" implicitly coerced to 42 here

a;              // "42"
b;              // 42 -- the number!
```

#### 真值&假值
第一章中，我们简要提到了真值和假值的性质：当一个非boolean值强制转换为boolean值时，它的值是true还是false呢？

JavaScript中表示“假值”的有如下值：
* `""`（空字符串）
* `0`, `-0`, `NaN`（无效的`number`）
* `null`, `undefined`
* `false`
不在“假值”列表中的其他任何值都表示“真值”，如：
* "hello"
* 42
* true
* [ ], [1,"2",3]
* { }, {a:42}
* function foo(){..}
需要谨记的是非boolean值强制转换为boolean值时只会做“真/假”转换。注意不要混淆了一个值看起来转换为boolean值，实际上并没有（转换为boolean值）的情况。

#### 等式
有四个等式运算符：`==`,`===`,`!=`,`!==`。其中`!`表示对应的“不相等”操作符；不要混淆了 *不相等* 和 *不等式* 的概念。

一般来说，==和===的区别在于：==仅检查两个值是否相等，而===既检查值是否相等又检查类型是否相同。然而，这种说法也不准确。更准确的说法应该是：==在允许强制类型转换的情况下来检查两个值是否相等，而===不允许强制转换来检查两个值是否相等；因此===常称作“严格相等”。

看一个==允许隐式强制转换而===不允许强制转换的例子：
```js
var a = "42";
var b = 42;

a == b;         // true
a === b;        // false
```
在`a == b`的等式中，JS发现两个值的类型不相同，所以它会经过一系列步骤将其中一个或两个值强制转换为不同的类型，使得两者的类型相同，然后再检查值是否相等。
读者会发现，经过类型转换后，`a == b`可能有两种相等的方式：一个是`42 == 42`，另一种是`"42" == "42"`。哪个是对的呢？

答案是："42"变成42，因此等式变成了42 == 42。在简单的情况下，哪种比较方式其实没什么影响，因为结果是一样的。但是在更复杂的情况下，比较结果以及如何得到这个结果的过程都会对程序有影响。

`a === b`的结果是false，因为不允许强制转换，所以简单的值比较肯定不相等。很多开发者觉得===更可控，因此建议总是用`===`而抛弃`==`。我觉得这种观点很片面。我认为 *如果花时间掌握==是怎样工作的*，它将会是一个提升程序质量的强大工具。

这里我们不详细展开讨论==比较时强制转换是怎样工作的。相关的知识大部分都很好理解，但是也要注意一些重要的特殊情况。完整的转换规则请参考[ES5规范的11.9.3节](http://www.ecma-international.org/ecma-262/5.1/)，你会发现与一片唱衰声相比，这其中的机制简单直接到让你大吃一惊。

这里把详细细节总结为几条简单的规则，以帮助你根据不同的情况选择用==还是===，规则如下：
* 如果比较的两个值中有一个可能是true或false值，应用===，不用==。
* 如果比较的两个值中有一个可能是这些特定值（0, ""或[]——空数组），应用===，不用==。
* 在其他所有情况下，都可以放心的用==。用==不仅安全无害，而且在很多情况下都可以简化你的代码，从而提高程序的可读性。
列举的这些规则要求你认真思考你的代码，仔细考虑对变量进行比较时得到的具体是什么类型的值。如果你能够确定值的类型，用==就很安全，大胆的用吧！如果你不能确定值的类型，就用===。就这么简单。

不等于!=与==相反，而!==与===相反。我们刚刚讨论的规则和结论相应的也都适用于它们。

如果你对两个非原始值，如object（包括function和array）进行比较，需要特别注意==和===的比较规则。因为这些值实际上是引用值，==和===只会简单的检查这两个引用值是否相等，而不是底层的真实值。
例如，默认情况下array值的强制转换会用逗号（,）将数组内所有值拼接成string类型的值。你可能觉得两个内容相同的数组用==比较时结果应该是true，但实际上并不是：
```js
var a = [1,2,3];
var b = [1,2,3];
var c = "1,2,3";

a == c;     // true
b == c;     // true
a == b;     // false
```
**注：** 更多有关==比较规则的知识，请参考ES5规范（11.9.3节）以及 *类型&语法* 一书的第四章，第二章有引用类型值的详细阐述。

#### 不等式
操作符`<`,`>`,`<=`和`>=`用于不等式比较，规范中也称为“关系比较”。通常它们用于有序的可比较的值，如number。不等式3 < 4是很容易理解的。

但是JavaScript的string类型的值根据一般的字母顺序（"bar" < "foo"）也可以用于不等式比较。

那么强制转换呢？ 与`==`比较类似的规则（虽然不完全一致）也适用于不等式操作符。值得一提的是，不等比较没有像“严格相等”一样不允许强制转换的“严格不等”操作符。
如：
```js
var a = 41;
var b = "42";
var c = "43";

a < b;      // true
b < c;      // true
```
这其中发生了什么？ 如ES5规范11.8.5节所述，如果`<`比较的两个值都是string类型，如上的`b < c`，那么就进行字典化（也即按照字典的字母顺序）比较。但是如果有一个值不是或者两个值都不是string类型，如上的`a < b`，两个值都会强制转换为number类型，然后进行数字比较。

比较不同类型值时你可能遇到的最大的问题——记住，没有“严格不等”形式——是其中一个值不能转换为合法的number，如：
```js
var a = 42;
var b = "foo";

a < b;      // false
a > b;      // false
a == b;     // false
```
等等，为什么这三个比较的结果都是false？因为在<和>比较中b值被转换为“无效的number值”NaN，规范明确指出NaN不能进行大于或小于比较。

`==`比较为false的原因有点不一样。前面我们讨论过，a==b转换为`42 == NaN`进行比较，因此结果也是false。

**注：** 更多有关不等式比较规则的知识，请参考ES5规范的第11.8.5节以及 *类型&语法* 一书的第四章。

## 变量

在JavaScript中，变量名（包括函数名）必须是合法的 *标识符*。如果考虑如Unicode等传统字符在内的话，标识符中关于合法字符的严格完整的规则就很复杂了。如果仅考虑普通的ASCII字母数字字符的话，这些规则就相当简单了。

标识符的首字符必须是a-z, A-Z,$或_，之后可以接任意字符，包括数字0-9。

一般来说，适用于属性名的规则也同样适用于变量标识符。然而，有些特殊单词不能作为变量名却可以作为属性名。这些单词称为“保留字”，也包括JS关键字在内（for, in, if, null, true, false等）。

### 函数作用域

如果用var关键字声明一个变量，那么这个变量属于当前函数的作用域，如果这个变量是声明在任何函数之外的最顶层，则属于全局作用域。

#### 变量提升
无论var出现在作用域中的什么位置，该条语句声明的变量都属于整个作用域，且在整个作用域中都是可以被访问的。

由于var声明的变量在概念上被“移动”到其所在作用域的最上面，因此这种行为被形象地称为 *提升*。从技术上，代码的编译机制可以更准确地解释这个过程，这里我们先略过不做详细讨论。
考虑：
```js
var a = 2;

foo();                  // works because `foo()`
                        // declaration is "hoisted"
function foo() {
    a = 3;
    console.log( a );   // 3
    var a;              // declaration is "hoisted"
						// to the top of `foo()`
}

console.log( a );   // 2
```
**注意：** 依赖变量 *提升* 来在用var定义之前使用变量的方式既不常见也不是一个好的习惯；这可能会造成程序混乱。我们更多的是使用函数声明提升，上面的代码中我们在`foo()`函数的正式声明之前就调用了它。

#### 嵌套作用域
当你声明了一个变量，它就可以在作用域中的任何位置被访问到，包括任何在更低级/次级的作用域内。例如：
```js
function foo() {
    var a = 1;
    function bar() {
        var b = 2;
        function baz() {
            var c = 3;
            console.log( a, b, c ); // 1 2 3
        }
        baz();
        console.log( a, b );        // 1 2
    }
    bar();
    console.log( a );               // 1
}

foo();
```
注意在函数bar()内无法访问变量c，因为它是在内部的baz()函数内声明的，同样的，函数foo()内也无法访问变量b。

如果试着访问一个在该作用域不能被访问的变量，会抛出`ReferenceError`错误。如果试着对一个未声明的变量赋值，在“严格模式”下会报错，但是非严格模式下则会在全局作用域创建这个变量（不好！）。我们看下这个例子：
```js
function foo() {
    a = 1;  // `a` not formally declared
}

foo();
a;          // 1 -- oops, auto global variable :(
```
这是一个典型的反面案例。千万不要这么做！永远记住正确地声明变量。

另外，ES6支持函数级的变量声明，用'let'关键字声明的变量只属于独立的代码块（花括号`{..}`）内。除了一些细节不一样之外，这种作用域的规则基本上与函数中的表现一致：
```js
function foo() {
    var a = 1;

    if (a >= 1) {
        let b = 2;

        while (b < 5) {
            let c = b * 2;
            b++;

            console.log( a + c );
        }
    }
}

foo();
// 5 7 9
```
由于使用let而不是var，变量b仅属于if语句而不属于整个foo()函数的作用域。同样的，c只属于while循环。块级作用域有助于更好更精细地管理变量作用域，从而简化代码的维护。
 
**注：** 更多关于作用域的知识，参考 *作用域&闭包* 一书。关于let块级作用域的知识参考 *ES6&未来* 一书。
 
## 条件语句
 
除了我们在第一章介绍的if语句之外，JavaScript还支持其他几种条件机制，我们后面再讨论。
 
有时候，你可能会写一大串的`if...else...if`语句，像这样：
```js
if (a == 2) {
    // do something
}
else if (a == 10) {
    // do another thing
}
else if (a == 42) {
    // do yet another thing
}
else {
    // fallback to here
}
```
这种写法没什么问题，但是显得很冗余，因为每个子句都需要做一次条件判断。这种情况下，可以用`switch`语句：
```js
switch (a) {
    case 2:
        // do something
        break;
    case 10:
        // do another thing
        break;
    case 42:
        // do yet another thing
        break;
    default:
        // fallback to here
}
```
如果希望每个子句中的语句只执行一次，则必须加上`break`。如果子句中没有break语句，当执行这个子句后，会继续执行下一个子句里面的语句，而不管下一个子句是否匹配条件判断语句。这种现象成为“通过”，有时候是很有用且希望出现的。
```js
switch (a) {
    case 2:
    case 10:
        // some cool stuff
        break;
    case 42:
        // other stuff
        break;
    default:
        // fallback
}
```
这里，不管a等于2还是10，都会执行"some cool stuff"代码语句。

JavaScript中另一个条件语句是被称为“三元操作符”的“条件操作符”。它更像是单个`if...else`语句的简写，如：
```js
var a = 42;

var b = (a > 41) ? "hello" : "world";

// 等同于:

// if (a > 41) {
//    b = "hello";
// }
// else {
//    b = "world";
// }
```
如果测试表达式（这里是`a>41`）结果为true，结果是第一个子句（"hello"），否则结果就是第二个子句（"world"）。然后再将结果赋值给变量b。

条件操作符不一定要用于赋值语句，但这无疑是它最常见的用法。

## 严格模式

ES5中为JS加入了“严格模式”，
 








