# 第一章：什么是作用域？

几乎所有编程语言的最基本范式之一都是将值存储于变量中，并在以后可以访问或修改这些值。实际上，正式这种对变量存取值的能力才使得程序具有 *状态*。

当然，即使没有这个概念，程序也可以执行某些任务，但是会受到极大的限制，也会失去很多乐趣。

在程序中引入变量带来了一系列我们现在要讨论的有趣问题：这些变量 *存在* 于哪里？换言之，它们保存在哪里？最重要的是，当我们的程序需要用它们时该如何找到它们？

这些问题说明我们需要一套完善的规则来规定变量的存储位置以及需要时如何找到这些变量。我们把这套规则称为：*作用域*。

但是，我们在何处以及如何设置这些作用域规则呢？

## 编译器理论

尽管JavaScript通常被归类为“动态”或“解释型”语言，但是实际上它是一门编译型语言。读者可能觉得这是不言而喻的，也可能感到很惊讶，这取决于你对各类语言的掌握程度。与许多传统编译型语言和各种分布式系统中跨平台编译结果不同的是，JavaScript不会预先编译好。

虽然与其他传统语言编译器相比，JavaScript引擎以比我们通常了解的更复杂的方式执行代码，但是它们执行的很多步骤是一样的。

在传统的语言编译过程中，你的程序，一大堆源代码，在被执行前会经历三个主要步骤，大致称为“编译”：
1. **标记化/分词**：将一串字符串拆分成（对这门语言来说）有意义的小块，称为标记。例如，对于程序：`var a=2;`，可能会被拆分成下列标记：`var`, `a`, `=`, `2`和`;`。如果标记中的空白有意义，则会保留，否则就会被去掉。

    **注：** 标记化（Tokenizing）和分词(Lexing)的区别微乎其微，主要区别是这些标记是以 *无状态* 方式还是以 *有状态* 方式被识别。简而言之，如果分词器根据有状态解析规则来判断`a`应该是一个单独的标记，还是仅仅是另一个标记的一部分，那么这种方式就是 __分词__。
2. **解析**：将标记流（数组）转换为代表程序语法结构的嵌套元素树。这棵树称为“AST”（Abstract Syntax Tree 抽象语法树）。

    `var a=2;`的AST的顶层节点称为`VariableDeclaration`，它有两个子节点：一个是`Identifier`（值为a）；另一个是`AssignmentExpression`，它又有一个子节点称为`NumbericLiteral`（值为2）。
3. **代码生成**：将AST转换为可执行代码的过程。该步骤根据不同语言、不同目标平台而有很大不同。
    
    因此，这里我们不具体展开细节，只需要知道通过某种方法将上文所述的“var a=2;”的AST转换成了一组机器指令，这组指令才实际上创建了一个变量a（包括分配内存等），然后在a中保存了一个值。
    
    **注**：引擎是如何管理系统资源的知识超出了我们的学习范畴，因此我们只需知道引擎能够创建和保存变量即可。
    
和大多数其他语言编译器一样，JavaScript引擎的工作比上述的三个步骤复杂的多。例如，在解析和代码生成阶段，肯定需要有消除冗余元素等优化执行性能的步骤。

因此，这里我只简略提及，但是我相信读者很快就会明白我们为什么要从一个相对高的层面介绍这些细节。

还有一点需要注意，JavaScript引擎没有多余的时间（其他语言编译器则有）来做优化，因为JavaScript编译不像其他语言一样提前在构建时编译。

对JavaScript来说，大多数情况下编译发生在代码被执行前几微秒（或更少）内。JS引擎使用了很多的技巧来保证最快的性能（如进行懒编译、甚至热重新编译的JITs等），这些技巧超出了我们讨论的“作用域”的范畴。

简单来说，任何JavaScript代码片段都必须在它被执行之前（通常就在之前）被编译。因此，JS编译器处理程序时，会先对他进行编译，然后再准备执行它，通知是立马就执行。

## 理解作用域

我们把学习作用域的方法想像成交谈的过程，那么，由谁来进行交谈呢？





























