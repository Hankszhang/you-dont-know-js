# 第一章：什么是作用域？

几乎所有编程语言的最基本范式之一都是将值存储于变量中，并在以后可以访问或修改这些值。实际上，正式这种对变量存取值的能力才使得程序具有 *状态*。

当然，即使没有这个概念，程序也可以执行某些任务，但是会受到极大的限制，也会失去很多乐趣。

在程序中引入变量带来了一系列我们现在要讨论的有趣问题：这些变量 *存在* 于哪里？换言之，它们保存在哪里？最重要的是，当我们的程序需要用它们时该如何找到它们？

这些问题说明我们需要一套完善的规则来规定变量的存储位置以及需要时如何找到这些变量。我们把这套规则称为：*作用域*。

但是，我们在何处以及如何设置这些作用域规则呢？

## 编译器理论

尽管JavaScript通常被归类为“动态”或“解释型”语言，但是实际上它是一门编译型语言。读者可能觉得这是不言而喻的，也可能感到很惊讶，这取决于你对各类语言的掌握程度。与许多传统编译型语言和各种分布式系统中跨平台编译结果不同的是，JavaScript不会预先编译好。

虽然与其他传统语言编译器相比，JavaScript引擎以比我们通常了解的更复杂的方式执行代码，但是它们执行的很多步骤是一样的。

在传统的语言编译过程中，你的程序，一大堆源代码，在被执行前会经历三个主要步骤，大致称为“编译”：
1. **标记化/分词**：将一串字符串拆分成（对这门语言来说）有意义的小块，称为标记。例如，对于程序：`var a=2;`，可能会被拆分成下列标记：`var`, `a`, `=`, `2`和`;`。如果标记中的空白有意义，则会保留，否则就会被去掉。

    **注：** 标记化（Tokenizing）和分词(Lexing)的区别微乎其微，主要区别是这些标记是以 *无状态* 方式还是以 *有状态* 方式被识别。简而言之，如果分词器根据有状态解析规则来判断`a`应该是一个单独的标记，还是仅仅是另一个标记的一部分，那么这种方式就是 __分词__。
2. **解析**：将标记流（数组）转换为代表程序语法结构的嵌套元素树。这棵树称为“AST”（Abstract Syntax Tree 抽象语法树）。

    `var a=2;`的AST的顶层节点称为`VariableDeclaration`，它有两个子节点：一个是`Identifier`（值为a）；另一个是`AssignmentExpression`，它又有一个子节点称为`NumbericLiteral`（值为2）。
3. **代码生成**：将AST转换为可执行代码的过程。该步骤根据不同语言、不同目标平台而有很大不同。
    
    因此，这里我们不具体展开细节，只需要知道通过某种方法将上文所述的“var a=2;”的AST转换成了一组机器指令，这组指令才实际上创建了一个变量a（包括分配内存等），然后在a中保存了一个值。
    
    **注**：引擎是如何管理系统资源的知识超出了我们的学习范畴，因此我们只需知道引擎能够创建和保存变量即可。
    
和大多数其他语言编译器一样，JavaScript引擎的工作比上述的三个步骤复杂的多。例如，在解析和代码生成阶段，肯定需要有消除冗余元素等优化执行性能的步骤。

因此，这里我只简略提及，但是我相信读者很快就会明白我们为什么要从一个相对高的层面介绍这些细节。

还有一点需要注意，JavaScript引擎没有多余的时间（其他语言编译器则有）来做优化，因为JavaScript编译不像其他语言一样提前在构建时编译。

对JavaScript来说，大多数情况下编译发生在代码被执行前几微秒（或更少）内。JS引擎使用了很多的技巧来保证最快的性能（如进行懒编译、甚至热重新编译的JITs等），这些技巧超出了我们讨论的“作用域”的范畴。

简单来说，任何JavaScript代码片段都必须在它被执行之前（通常就在之前）被编译。因此，JS编译器处理程序时，会先对他进行编译，然后再准备执行它，通知是立马就执行。

## 理解作用域

我们把学习作用域的方法想像成交谈的过程，那么，由谁来进行交谈呢？

### 演员表
我们先来认识处理程序`var a = 2;`过程中的几个角色，以便我们理解马上将要听到的对话：
1. *引擎*：负责整个编译过程和执行JavaScript程序
2. *编译器*：引擎的朋友之一；处理解析和代码生成等脏活累活
3. *作用域*：引擎的另一个朋友；收集并维护由所有声明的标识符（变量）组成的查询表，对当前执行的代码如何访问这些变量强加一系列严格的规则
如果你想 *彻底理解* JavaScript是如何工作的，那么你需要从引擎的角度，想其所想，问其所问，答其所答。

### 来来回回
第一眼看到程序`var a = 2;`，你很可能认为它是一条语句。但是我们的新朋友引擎可不是这么认为的。实际上，引擎会把它当作两条不同的语句，其中一条编译器在编译时会处理，另一条引擎在执行时会处理。

现在我们分开来看引擎和它的朋友们是怎么处理程序`var a = 2;`的。

拿到这个程序后，编译器做的第一件事是分词，把程序拆分成各个标记，然后将它们解析成语法树。但是当编译器到代码生成阶段时，它处理这个程序的方式可能与我们设想的不一样。

一个合理的解释是编译器会综合这样的伪代码：“给一个变量分配内存，将其命名为a，然后把值2保存到这个变量中”来生成代码。很遗憾，这是不准确的。

其实，编译器会这样处理：
1. 遇到`var a`时，编译器询问作用域是否在特定的作用域范围中已经存在变量a。如果存在，编译器忽略这条声明语句并继续向前执行。否则，编译器要求作用域在其范围内声明一个新的变量a。
2. 然后编译器生成供引擎执行的代码来处理赋值语句`a = 2`。引擎运行的代码会先询问作用域在当前作用域范围内是否存在一个可被访问的变量a。如果存在，引擎就用这个变量；如果不存在，引擎会到别的地方去找（参见下文的嵌套作用域）。
如果引擎最终找到了这个变量，则把值2赋给这个变量。如果没有找到，引擎会举手并大喊出错了！

总结：变量赋值被当作两个不同的行为：首先，编译器声明一个变量（如果在当前作用域中还未被声明），然后在执行的时候，引擎在作用域中查找这个变量，如果找到便对其赋值。

### 编译器发言





























