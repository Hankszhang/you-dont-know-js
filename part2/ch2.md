# 第二章：词法作用域

目前主要有两种模型来解释作用域的工作原理：**词法作用域** 和 **动态作用域**。我们这里主要讨论JavaScript使用的词法作用域，附录A中对动态作用域进行了阐述。

## 词法分析
正如我们在第一章中讨论过的，标准的语言编译器的第一步一般都是词法分析，它正是理解词法作用域的基础。

词法作用域是在进行词法分析时定义的作用域。也就是说，词法作用域基于你编写代码时创建的变量和作用域块，因此在分词器执行你的代码时它是不可更改的。

**注**：采取某些方法可以欺骗词法作用域，从而在分词之后还可以修改作用域，但是不提倡这么做。

考虑下面这段代码：
```js
function foo(a) {
    var b = a * 2;
    function bar(c) {
        console.log( a, b, c );
    }
    bar(b * 3);
}
foo( 2 ); // 2 4 12
```
这段代码中包含了三层嵌套作用域。可以将其想象成三个依次包裹的气泡。
<img src="/assets/fig5.png" width="500">

**气泡1**：包含全局作用域，只有一个标识符：foo；

**气泡2**：包含函数foo的作用域，有三个标识符：a、bar和b；

**气泡3**：包含函数bar的作用域，只有一个标识符：c

作用域气泡在作用域块被书写的位置定义，一个嵌套在另一个内。气泡bar被完全包含在气泡foo内，因为这正是我们定义函数bar的位置。

### 查找
上文中的这些气泡的结构和相对位置，很好的解释了引擎是如何找到它需要的标识符的。

上面的代码中，引擎执行`congsole.log(..)`语句时，会查找三个相关的变量a、b和c。首先从最内层的气泡，也即bar函数的作用域，开始查找。没找到a，因此往上一层，来到上一层嵌套的气泡，也即foo函数的作用域，在这里找到了a，因此直接使用它。查找b也是同样的过程，但是对于c，可以直接在bar函数内找到。

**作用域查找一旦找到第一个匹配则立即停止**。在嵌套作用域的不同层级可以使用相同名字的标识符，内部的标识符会“遮蔽”外部的同名标识符。不论有无“遮蔽”效应，作用域查找总是从当前正在执行的作用域开始，然后一次向外/向上直到找到第一个匹配，则立即停止。

**注**：全局变量是全局对象（浏览器中是window对象）的的属性，因此也可以不直接通过词法作用域方式引用全局变量，而是作为全局对象的属性间接引用：window.a。这种方法使得全局变量即使被遮蔽了依然可以被访问到。

不管函数在哪里被调用、也不管是怎样被调用，它的词法作用域**只**由其被声明的位置确定。

## 欺骗词法





